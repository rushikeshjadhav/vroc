From 32141c1765967e37d6f1accdf124c166bc103c3b Mon Sep 17 00:00:00 2001
From: Jes Sorensen <jsorensen@fb.com>
Date: Tue, 11 Apr 2017 12:54:26 -0400
Subject: [RHEL7.5 PATCH 070/169] Retire mdassemble

mdassemble doesn't handle container based arrays, no support for sysfs,
etc. It has not been actively maintained for years, so time to send it
off to retirement.

Signed-off-by: Jes Sorensen <jsorensen@fb.com>
---
 Assemble.c    | 21 +++-------------
 Makefile      | 37 ----------------------------
 Manage.c      | 10 +-------
 Monitor.c     |  3 ---
 mdassemble.c  | 79 -----------------------------------------------------------
 super-ddf.c   | 30 -----------------------
 super-gpt.c   |  6 -----
 super-intel.c | 52 +--------------------------------------
 super-mbr.c   |  8 ------
 super0.c      | 11 ---------
 super1.c      | 21 +++-------------
 util.c        | 37 +++-------------------------
 12 files changed, 12 insertions(+), 303 deletions(-)
 delete mode 100644 mdassemble.c

diff --git a/Assemble.c b/Assemble.c
index 0db428f..b828523 100644
--- a/Assemble.c
+++ b/Assemble.c
@@ -222,13 +222,11 @@ static int select_devices(struct mddev_dev *devlist,
 					pr_err("%s is a container, but we are looking for components\n",
 					       devname);
 				tmpdev->used = 2;
-#if !defined(MDASSEMBLE) || defined(MDASSEMBLE) && defined(MDASSEMBLE_AUTO)
 			} if (!tst && (tst = super_by_fd(dfd, NULL)) == NULL) {
 				if (report_mismatch)
 					pr_err("not a recognisable container: %s\n",
 					       devname);
 				tmpdev->used = 2;
-#endif
 			} else if (!tst->ss->load_container
 				   || tst->ss->load_container(tst, dfd, NULL)) {
 				if (report_mismatch)
@@ -574,9 +572,7 @@ static int load_devices(struct devs *devices, char *devmap,
 	struct mddev_dev *tmpdev;
 	int devcnt = 0;
 	int nextspare = 0;
-#ifndef MDASSEMBLE
 	int bitmap_done = 0;
-#endif
 	int most_recent = -1;
 	int bestcnt = 0;
 	int *best = *bestp;
@@ -592,7 +588,6 @@ static int load_devices(struct devs *devices, char *devmap,
 		if (tmpdev->used != 1)
 			continue;
 		/* looks like a good enough match to update the super block if needed */
-#ifndef MDASSEMBLE
 		if (c->update) {
 			/* prepare useful information in info structures */
 			struct stat stb2;
@@ -683,9 +678,7 @@ static int load_devices(struct devs *devices, char *devmap,
 				else
 					bitmap_done = 1;
 			}
-		} else
-#endif
-		{
+		} else {
 			dfd = dev_open(devname,
 				       tmpdev->disposition == 'I'
 				       ? O_RDWR : (O_RDWR|O_EXCL));
@@ -1097,7 +1090,6 @@ static int start_array(int mdfd,
 		 * it read-only and let the grow code make it writable.
 		 */
 		int rv;
-#ifndef MDASSEMBLE
 		if (content->reshape_active &&
 		    !(content->reshape_active & RESHAPE_NO_BACKUP) &&
 		    content->delta_disks <= 0) {
@@ -1122,7 +1114,6 @@ static int start_array(int mdfd,
 			rv = sysfs_set_str(content, NULL,
 					   "array_state", "readonly");
 		} else
-#endif
 			rv = ioctl(mdfd, RUN_ARRAY, NULL);
 		reopen_mddev(mdfd); /* drop O_EXCL */
 		if (rv == 0) {
@@ -1506,7 +1497,6 @@ try_again:
 		ioctl(mdfd, STOP_ARRAY, NULL);
 	}
 
-#ifndef MDASSEMBLE
 	if (content != &info) {
 		/* This is a member of a container.  Try starting the array. */
 		int err;
@@ -1515,7 +1505,7 @@ try_again:
 		close(mdfd);
 		return err;
 	}
-#endif
+
 	/* Ok, no bad inconsistancy, we can try updating etc */
 	devices = xcalloc(num_devs, sizeof(*devices));
 	devmap = xcalloc(num_devs, content->array.raid_disks);
@@ -1668,14 +1658,13 @@ try_again:
 		return 1;
 	}
 	st->ss->getinfo_super(st, content, NULL);
-#ifndef MDASSEMBLE
 	if (sysfs_init(content, mdfd, NULL)) {
 		pr_err("Unable to initialize sysfs\n");
 		close(mdfd);
 		free(devices);
 		return 1;
 	}
-#endif
+
 	/* after reload context, store journal_clean in context */
 	content->journal_clean = journal_clean;
 	for (i=0; i<bestcnt; i++) {
@@ -1761,7 +1750,6 @@ try_again:
 	 * that was moved aside due to the reshape overwriting live data
 	 * The code of doing this lives in Grow.c
 	 */
-#ifndef MDASSEMBLE
 	if (content->reshape_active &&
 	    !(content->reshape_active & RESHAPE_NO_BACKUP)) {
 		int err = 0;
@@ -1813,7 +1801,6 @@ try_again:
 			return err;
 		}
 	}
-#endif
 
 	/* Almost ready to actually *do* something */
 	/* First, fill in the map, so that udev can find our name
@@ -1876,7 +1863,6 @@ try_again:
 	return rv == 2 ? 0 : rv;
 }
 
-#ifndef MDASSEMBLE
 int assemble_container_content(struct supertype *st, int mdfd,
 			       struct mdinfo *content, struct context *c,
 			       char *chosen_name, int *result)
@@ -2119,4 +2105,3 @@ int assemble_container_content(struct supertype *st, int mdfd,
 	return err;
 	/* FIXME should have an O_EXCL and wait for read-auto */
 }
-#endif
diff --git a/Makefile b/Makefile
index 5ff6cc0..a5d2a0a 100644
--- a/Makefile
+++ b/Makefile
@@ -158,18 +158,6 @@ MON_SRCS = $(patsubst %.o,%.c,$(MON_OBJS))
 STATICSRC = pwgr.c
 STATICOBJS = pwgr.o
 
-ASSEMBLE_SRCS := mdassemble.c Assemble.c Manage.c config.c policy.c dlink.c util.c \
-	maps.c lib.c xmalloc.c \
-	super0.c super1.c super-ddf.c super-intel.c sha1.c crc32.c sg_io.c mdstat.c \
-	platform-intel.c probe_roms.c sysfs.c super-mbr.c super-gpt.c mapfile.c \
-	crc32c.c
-ASSEMBLE_AUTO_SRCS := mdopen.c
-ASSEMBLE_FLAGS:= $(CFLAGS) -DMDASSEMBLE
-ifdef MDASSEMBLE_AUTO
-ASSEMBLE_SRCS += $(ASSEMBLE_AUTO_SRCS)
-ASSEMBLE_FLAGS += -DMDASSEMBLE_AUTO
-endif
-
 all : mdadm mdmon
 man : mdadm.man md.man mdadm.conf.man mdmon.man raid6check.man
 
@@ -222,31 +210,6 @@ test_stripe : restripe.c xmalloc.o mdadm.h
 raid6check : raid6check.o mdadm.h $(CHECK_OBJS)
 	$(CC) $(CXFLAGS) $(LDFLAGS) -o raid6check raid6check.o $(CHECK_OBJS)
 
-mdassemble : $(ASSEMBLE_SRCS) $(INCL)
-	$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(ASSEMBLE_FLAGS) -o mdassemble $(ASSEMBLE_SRCS)  $(STATICSRC)
-
-mdassemble.diet : $(ASSEMBLE_SRCS) $(INCL)
-	rm -f $(OBJS)
-	$(DIET_GCC) $(ASSEMBLE_FLAGS) -o mdassemble $(ASSEMBLE_SRCS)  $(STATICSRC)
-
-mdassemble.static : $(ASSEMBLE_SRCS) $(INCL)
-	rm -f $(OBJS)
-	$(CC) $(LDFLAGS) $(CPPFLAGS) $(ASSEMBLE_FLAGS) -static -DHAVE_STDINT_H -o mdassemble.static $(ASSEMBLE_SRCS) $(STATICSRC)
-
-mdassemble.auto : $(ASSEMBLE_SRCS) $(INCL) $(ASSEMBLE_AUTO_SRCS)
-	rm -f mdassemble.static
-	$(MAKE) MDASSEMBLE_AUTO=1 mdassemble.static
-	mv mdassemble.static mdassemble.auto
-
-mdassemble.uclibc : $(ASSEMBLE_SRCS) $(INCL)
-	rm -f $(OJS)
-	$(UCLIBC_GCC) $(ASSEMBLE_FLAGS) -DUCLIBC -DHAVE_STDINT_H -static -o mdassemble.uclibc $(ASSEMBLE_SRCS) $(STATICSRC)
-
-# This doesn't work
-mdassemble.klibc : $(ASSEMBLE_SRCS) $(INCL)
-	rm -f $(OBJS)
-	$(KLIBC_GCC) $(ASSEMBLE_FLAGS) -o mdassemble $(ASSEMBLE_SRCS)
-
 mdadm.8 : mdadm.8.in
 	sed -e 's/{DEFAULT_METADATA}/$(DEFAULT_METADATA)/g' \
 	-e 's,{MAP_PATH},$(MAP_PATH),g'  mdadm.8.in > mdadm.8
diff --git a/Manage.c b/Manage.c
index 9e69132..bb84d28 100644
--- a/Manage.c
+++ b/Manage.c
@@ -41,12 +41,9 @@ int Manage_ro(char *devname, int fd, int readonly)
 	 *
 	 */
 	mdu_array_info_t array;
-#ifndef MDASSEMBLE
 	struct mdinfo *mdi;
-#endif
 	int rv = 0;
 
-#ifndef MDASSEMBLE
 	/* If this is an externally-managed array, we need to modify the
 	 * metadata_version so that mdmon doesn't undo our change.
 	 */
@@ -90,7 +87,7 @@ int Manage_ro(char *devname, int fd, int readonly)
 		}
 		goto out;
 	}
-#endif
+
 	if (md_get_array_info(fd, &array)) {
 		pr_err("%s does not appear to be active.\n",
 			devname);
@@ -114,14 +111,10 @@ int Manage_ro(char *devname, int fd, int readonly)
 		}
 	}
 out:
-#ifndef MDASSEMBLE
 	sysfs_free(mdi);
-#endif
 	return rv;
 }
 
-#ifndef MDASSEMBLE
-
 static void remove_devices(char *devnm, char *path)
 {
 	/*
@@ -1802,4 +1795,3 @@ int move_spare(char *from_devname, char *to_devname, dev_t devid)
 	close(fd2);
 	return 0;
 }
-#endif
diff --git a/Monitor.c b/Monitor.c
index 036a561..1f15377 100644
--- a/Monitor.c
+++ b/Monitor.c
@@ -1058,8 +1058,6 @@ int Wait(char *dev)
 	}
 }
 
-#ifndef MDASSEMBLE
-
 static char *clean_states[] = {
 	"clear", "inactive", "readonly", "read-auto", "clean", NULL };
 
@@ -1151,4 +1149,3 @@ int WaitClean(char *dev, int sock, int verbose)
 
 	return rv;
 }
-#endif /* MDASSEMBLE */
diff --git a/mdassemble.c b/mdassemble.c
deleted file mode 100644
index f0833bc..0000000
--- a/mdassemble.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * mdassemble - assemble Linux "md" devices aka RAID arrays.
- *
- * Copyright (C) 2001-2009 Neil Brown <neilb@suse.de>
- * Copyright (C) 2003 Luca Berra <bluca@vodka.it>
- *
- *
- *    This program is free software; you can redistribute it and/or modify
- *    it under the terms of the GNU General Public License as published by
- *    the Free Software Foundation; either version 2 of the License, or
- *    (at your option) any later version.
- *
- *    This program is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *    GNU General Public License for more details.
- *
- *    You should have received a copy of the GNU General Public License
- *    along with this program; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *    Author: Neil Brown
- *    Email: <neilb@suse.de>
- */
-
-#include "mdadm.h"
-#include "md_p.h"
-
-char const Name[] = "mdassemble";
-
-#ifndef MDASSEMBLE_AUTO
-/* from mdopen.c */
-int open_mddev(char *dev, int report_errors/*unused*/)
-{
-	struct mdu_array_info_s array;
-	int mdfd = open(dev, O_RDONLY);
-	if (mdfd < 0)
-		pr_err("error opening %s: %s\n", dev, strerror(errno));
-	else if (md_get_array_info(mdfd, &array) != 0) {
-		pr_err("%s does not appear to be an md device\n", dev);
-		close(mdfd);
-		mdfd = -1;
-	}
-	return mdfd;
-}
-int create_mddev(char *dev, char *name, int autof/*unused*/, int trustworthy,
-		 char *chosen)
-{
-	return open_mddev(dev, 0);
-}
-#endif
-
-int rv;
-int mdfd = -1;
-
-int main(int argc, char *argv[])
-{
-	struct mddev_ident *array_list =  conf_get_ident(NULL);
-	struct context c = { .freeze_reshape = 1 };
-	if (!array_list) {
-		pr_err("No arrays found in config file\n");
-		rv = 1;
-	} else
-		for (; array_list; array_list = array_list->next) {
-			mdu_array_info_t array;
-			if (strcasecmp(array_list->devname, "<ignore>") == 0)
-				continue;
-			mdfd = open_mddev(array_list->devname, 0);
-			if (mdfd >= 0 && md_get_array_info(mdfd, &array) == 0) {
-				rv |= Manage_ro(array_list->devname, mdfd, -1); /* make it readwrite */
-				continue;
-			}
-			if (mdfd >= 0)
-				close(mdfd);
-			rv |= Assemble(array_list->st, array_list->devname,
-				       array_list, NULL, &c);
-		}
-	return rv;
-}
diff --git a/super-ddf.c b/super-ddf.c
index c6037c1..796eaa5 100644
--- a/super-ddf.c
+++ b/super-ddf.c
@@ -500,7 +500,6 @@ struct ddf_super {
 	} *dlist, *add_list;
 };
 
-#ifndef MDASSEMBLE
 static int load_super_ddf_all(struct supertype *st, int fd,
 			      void **sbp, char *devname);
 static int get_svd_state(const struct ddf_super *, const struct vcl *);
@@ -518,7 +517,6 @@ static int validate_geometry_ddf_bvd(struct supertype *st,
 				     unsigned long long data_offset,
 				     char *dev, unsigned long long *freesize,
 				     int verbose);
-#endif
 
 static void free_super_ddf(struct supertype *st);
 static int all_ff(const char *guid);
@@ -1305,8 +1303,6 @@ static struct supertype *match_metadata_desc_ddf(char *arg)
 	return st;
 }
 
-#ifndef MDASSEMBLE
-
 static mapping_t ddf_state[] = {
 	{ "Optimal", 0},
 	{ "Degraded", 1},
@@ -1355,7 +1351,6 @@ static mapping_t ddf_sec_level[] = {
 	{ "Spanned", DDF_2SPANNED},
 	{ NULL, 0}
 };
-#endif
 
 static int all_ff(const char *guid)
 {
@@ -1382,7 +1377,6 @@ static const char *guid_str(const char *guid)
 	return (const char *) buf;
 }
 
-#ifndef MDASSEMBLE
 static void print_guid(char *guid, int tstamp)
 {
 	/* A GUIDs are part (or all) ASCII and part binary.
@@ -1748,7 +1742,6 @@ static void detail_super_ddf(struct supertype *st, char *homehost)
 	printf("     Virtual Disks : %d\n", cnt);
 	printf("\n");
 }
-#endif
 
 static const char *vendors_with_variable_volume_UUID[] = {
 	"LSI      ",
@@ -1795,7 +1788,6 @@ static void uuid_of_ddf_subarray(const struct ddf_super *ddf,
 	memcpy(uuid, sha, 4*4);
 }
 
-#ifndef MDASSEMBLE
 static void brief_detail_super_ddf(struct supertype *st)
 {
 	struct mdinfo info;
@@ -1811,7 +1803,6 @@ static void brief_detail_super_ddf(struct supertype *st)
 	fname_from_uuid(st, &info, nbuf,':');
 	printf(" UUID=%s", nbuf + 5);
 }
-#endif
 
 static int match_home_ddf(struct supertype *st, char *homehost)
 {
@@ -1833,7 +1824,6 @@ static int match_home_ddf(struct supertype *st, char *homehost)
 		ddf->controller.vendor_data[len] == 0);
 }
 
-#ifndef MDASSEMBLE
 static int find_index_in_bvd(const struct ddf_super *ddf,
 			     const struct vd_config *conf, unsigned int n,
 			     unsigned int *n_bvd)
@@ -1914,7 +1904,6 @@ bad:
 	pr_err("Could't find disk %d in array %u\n", n, inst);
 	return NULL;
 }
-#endif
 
 static int find_phys(const struct ddf_super *ddf, be32 phys_refnum)
 {
@@ -2274,7 +2263,6 @@ static unsigned int find_vde_by_name(const struct ddf_super *ddf,
 	return DDF_NOTFOUND;
 }
 
-#ifndef MDASSEMBLE
 static unsigned int find_vde_by_guid(const struct ddf_super *ddf,
 				     const char *guid)
 {
@@ -2286,7 +2274,6 @@ static unsigned int find_vde_by_guid(const struct ddf_super *ddf,
 			return i;
 	return DDF_NOTFOUND;
 }
-#endif
 
 static int init_super_ddf(struct supertype *st,
 			  mdu_array_info_t *info,
@@ -2507,7 +2494,6 @@ static int chunk_to_shift(int chunksize)
 	return ffs(chunksize/512)-1;
 }
 
-#ifndef MDASSEMBLE
 struct extent {
 	unsigned long long start, size;
 };
@@ -2608,7 +2594,6 @@ static unsigned long long find_space(
 	free(e);
 	return INVALID_SECTORS;
 }
-#endif
 
 static int init_super_ddf_bvd(struct supertype *st,
 			      mdu_array_info_t *info,
@@ -2727,7 +2712,6 @@ static int init_super_ddf_bvd(struct supertype *st,
 	return 1;
 }
 
-#ifndef MDASSEMBLE
 static void add_to_super_ddf_bvd(struct supertype *st,
 				 mdu_disk_info_t *dk, int fd, char *devname,
 				 unsigned long long data_offset)
@@ -3015,7 +2999,6 @@ static int remove_from_super_ddf(struct supertype *st, mdu_disk_info_t *dk)
 	}
 	return 0;
 }
-#endif
 
 /*
  * This is the write_init_super method for a ddf container.  It is
@@ -3176,7 +3159,6 @@ static int _write_super_to_disk(struct ddf_super *ddf, struct dl *d)
 	return 1;
 }
 
-#ifndef MDASSEMBLE
 static int __write_init_super_ddf(struct supertype *st)
 {
 	struct ddf_super *ddf = st->sb;
@@ -3259,8 +3241,6 @@ static int write_init_super_ddf(struct supertype *st)
 	}
 }
 
-#endif
-
 static __u64 avail_size_ddf(struct supertype *st, __u64 devsize,
 			    unsigned long long data_offset)
 {
@@ -3270,8 +3250,6 @@ static __u64 avail_size_ddf(struct supertype *st, __u64 devsize,
 	return devsize - 32*1024*2;
 }
 
-#ifndef MDASSEMBLE
-
 static int reserve_space(struct supertype *st, int raiddisks,
 			 unsigned long long size, int chunk,
 			 unsigned long long data_offset,
@@ -3653,8 +3631,6 @@ static int load_container_ddf(struct supertype *st, int fd,
 	return load_super_ddf_all(st, fd, &st->sb, devname);
 }
 
-#endif /* MDASSEMBLE */
-
 static int check_secondary(const struct vcl *vc)
 {
 	const struct vd_config *conf = &vc->conf;
@@ -4075,7 +4051,6 @@ static int compare_super_ddf(struct supertype *st, struct supertype *tst)
 	return 0;
 }
 
-#ifndef MDASSEMBLE
 /*
  * A new array 'a' has been started which claims to be instance 'inst'
  * within container 'c'.
@@ -5196,7 +5171,6 @@ static struct mdinfo *ddf_activate_spare(struct active_array *a,
 	*updates = mu;
 	return rv;
 }
-#endif /* MDASSEMBLE */
 
 static int ddf_level_to_layout(int level)
 {
@@ -5225,7 +5199,6 @@ static void default_geometry_ddf(struct supertype *st, int *level, int *layout,
 }
 
 struct superswitch super_ddf = {
-#ifndef	MDASSEMBLE
 	.examine_super	= examine_super_ddf,
 	.brief_examine_super = brief_examine_super_ddf,
 	.brief_examine_subarrays = brief_examine_subarrays_ddf,
@@ -5239,7 +5212,6 @@ struct superswitch super_ddf = {
 	.load_container	= load_container_ddf,
 	.copy_metadata = copy_metadata_ddf,
 	.kill_subarray  = kill_subarray_ddf,
-#endif
 	.match_home	= match_home_ddf,
 	.uuid_from_super= uuid_from_super_ddf,
 	.getinfo_super  = getinfo_super_ddf,
@@ -5259,7 +5231,6 @@ struct superswitch super_ddf = {
 
 	.external	= 1,
 
-#ifndef MDASSEMBLE
 /* for mdmon */
 	.open_new       = ddf_open_new,
 	.set_array_state= ddf_set_array_state,
@@ -5268,6 +5239,5 @@ struct superswitch super_ddf = {
 	.process_update	= ddf_process_update,
 	.prepare_update	= ddf_prepare_update,
 	.activate_spare = ddf_activate_spare,
-#endif
 	.name = "ddf",
 };
diff --git a/super-gpt.c b/super-gpt.c
index bb38a97..a1e9aa9 100644
--- a/super-gpt.c
+++ b/super-gpt.c
@@ -47,7 +47,6 @@ static void free_gpt(struct supertype *st)
 	st->sb = NULL;
 }
 
-#ifndef MDASSEMBLE
 static void examine_gpt(struct supertype *st, char *homehost)
 {
 	struct GPT *gpt = st->sb + 512;
@@ -66,7 +65,6 @@ static void examine_gpt(struct supertype *st, char *homehost)
 			);
 	}
 }
-#endif /* MDASSEMBLE */
 
 static int load_gpt(struct supertype *st, int fd, char *devname)
 {
@@ -199,7 +197,6 @@ static struct supertype *match_metadata_desc(char *arg)
 	return st;
 }
 
-#ifndef MDASSEMBLE
 static int validate_geometry(struct supertype *st, int level,
 			     int layout, int raiddisks,
 			     int *chunk, unsigned long long size,
@@ -210,13 +207,10 @@ static int validate_geometry(struct supertype *st, int level,
 	pr_err("gpt metadata cannot be used this way\n");
 	return 0;
 }
-#endif
 
 struct superswitch gpt = {
-#ifndef MDASSEMBLE
 	.examine_super = examine_gpt,
 	.validate_geometry = validate_geometry,
-#endif
 	.match_metadata_desc = match_metadata_desc,
 	.load_super = load_gpt,
 	.store_super = store_gpt,
diff --git a/super-intel.c b/super-intel.c
index 84dfe2b..0aed57c 100644
--- a/super-intel.c
+++ b/super-intel.c
@@ -260,9 +260,7 @@ struct bbm_log {
 	struct bbm_log_entry marked_block_entries[BBM_LOG_MAX_ENTRIES];
 } __attribute__ ((__packed__));
 
-#ifndef MDASSEMBLE
 static char *map_state_str[] = { "normal", "uninitialized", "degraded", "failed" };
-#endif
 
 #define BLOCKS_PER_KB	(1024/512)
 
@@ -672,12 +670,10 @@ static struct supertype *match_metadata_desc_imsm(char *arg)
 	return st;
 }
 
-#ifndef MDASSEMBLE
 static __u8 *get_imsm_version(struct imsm_super *mpb)
 {
 	return &mpb->sig[MPB_SIG_LEN];
 }
-#endif
 
 /* retrieve a disk directly from the anchor when the anchor is known to be
  * up-to-date, currently only at load time
@@ -784,7 +780,6 @@ static size_t sizeof_imsm_dev(struct imsm_dev *dev, int migr_state)
 	return size;
 }
 
-#ifndef MDASSEMBLE
 /* retrieve disk serial number list from a metadata update */
 static struct disk_info *get_disk_info(struct imsm_update_create_array *update)
 {
@@ -796,7 +791,6 @@ static struct disk_info *get_disk_info(struct imsm_update_create_array *update)
 
 	return inf;
 }
-#endif
 
 static struct imsm_dev *__get_imsm_dev(struct imsm_super *mpb, __u8 index)
 {
@@ -847,7 +841,6 @@ static inline struct bbm_log_block_addr __cpu_to_le48(unsigned long long sec)
 	return addr;
 }
 
-#ifndef MDASSEMBLE
 /* get size of the bbm log */
 static __u32 get_imsm_bbm_log_size(struct bbm_log *log)
 {
@@ -978,7 +971,6 @@ static int clear_badblock(struct bbm_log *log, const __u8 idx, const unsigned
 
 	return 1;
 }
-#endif /* MDASSEMBLE */
 
 /* allocate and load BBM log from metadata */
 static int load_bbm_log(struct intel_super *super)
@@ -1423,7 +1415,6 @@ static int is_gen_migration(struct imsm_dev *dev);
 
 #define IMSM_4K_DIV 8
 
-#ifndef MDASSEMBLE
 static __u64 blocks_per_migr_unit(struct intel_super *super,
 				  struct imsm_dev *dev);
 
@@ -1698,7 +1689,6 @@ void examine_migr_rec_imsm(struct intel_super *super)
 		break;
 	}
 }
-#endif /* MDASSEMBLE */
 
 void convert_from_4k_imsm_migr_rec(struct intel_super *super)
 {
@@ -1858,7 +1848,6 @@ static int imsm_check_attributes(__u32 attributes)
 	return ret_val;
 }
 
-#ifndef MDASSEMBLE
 static void getinfo_super_imsm(struct supertype *st, struct mdinfo *info, char *map);
 
 static void examine_super_imsm(struct supertype *st, char *homehost)
@@ -2572,8 +2561,6 @@ static int export_detail_platform_imsm(int verbose, char *controller_path)
 	return result;
 }
 
-#endif
-
 static int match_home_imsm(struct supertype *st, char *homehost)
 {
 	/* the imsm metadata format does not specify any host
@@ -2984,7 +2971,6 @@ out:
 	return retval;
 }
 
-#ifndef MDASSEMBLE
 /*******************************************************************************
  * function: imsm_create_metadata_checkpoint_update
  * Description: It creates update for checkpoint change.
@@ -3125,7 +3111,6 @@ static int write_imsm_migr_rec(struct supertype *st)
 		close(fd);
 	return retval;
 }
-#endif /* MDASSEMBLE */
 
 /* spare/missing disks activations are not allowe when
  * array/container performs reshape operation, because
@@ -3396,7 +3381,6 @@ static __u8 imsm_check_degraded(struct intel_super *super, struct imsm_dev *dev,
 static int imsm_count_failed(struct intel_super *super, struct imsm_dev *dev,
 			     int look_in_map);
 
-#ifndef MDASSEMBLE
 static void manage_second_map(struct intel_super *super, struct imsm_dev *dev)
 {
 	if (is_gen_migration(dev)) {
@@ -3412,7 +3396,6 @@ static void manage_second_map(struct intel_super *super, struct imsm_dev *dev)
 		}
 	}
 }
-#endif
 
 static struct imsm_disk *get_imsm_missing(struct intel_super *super, __u8 index)
 {
@@ -3994,7 +3977,6 @@ load_imsm_disk(int fd, struct intel_super *super, char *devname, int keep_fd)
 	return 0;
 }
 
-#ifndef MDASSEMBLE
 /* When migrating map0 contains the 'destination' state while map1
  * contains the current state.  When not migrating map0 contains the
  * current state.  This routine assumes that map[0].map_state is set to
@@ -4082,7 +4064,6 @@ static void end_migration(struct imsm_dev *dev, struct intel_super *super,
 	dev->vol.curr_migr_unit = 0;
 	map->map_state = map_state;
 }
-#endif
 
 static int parse_raid_devices(struct intel_super *super)
 {
@@ -4528,7 +4509,6 @@ static int find_missing(struct intel_super *super)
 	return 0;
 }
 
-#ifndef MDASSEMBLE
 static struct intel_disk *disk_list_get(__u8 *serial, struct intel_disk *disk_list)
 {
 	struct intel_disk *idisk = disk_list;
@@ -5066,7 +5046,6 @@ static int load_container_imsm(struct supertype *st, int fd, char *devname)
 {
 	return load_super_imsm_all(st, fd, &st->sb, devname, NULL, 1);
 }
-#endif
 
 static int load_super_imsm(struct supertype *st, int fd, char *devname)
 {
@@ -5483,7 +5462,6 @@ static int init_super_imsm(struct supertype *st, mdu_array_info_t *info,
 	return 1;
 }
 
-#ifndef MDASSEMBLE
 static int add_to_super_imsm_volume(struct supertype *st, mdu_disk_info_t *dk,
 				     int fd, char *devname)
 {
@@ -6028,7 +6006,6 @@ static int mgmt_disk(struct supertype *st)
 
 	return 0;
 }
-#endif
 
 __u32 crc32c_le(__u32 crc, unsigned char const *p, size_t len);
 
@@ -6136,8 +6113,6 @@ out:
 	return ret;
 }
 
-#ifndef MDASSEMBLE
-
 static int write_init_ppl_imsm_all(struct supertype *st, struct mdinfo *info)
 {
 	struct intel_super *super = st->sb;
@@ -6199,7 +6174,6 @@ static int write_init_super_imsm(struct supertype *st)
 
 	return rv;
 }
-#endif
 
 static int store_super_imsm(struct supertype *st, int fd)
 {
@@ -6209,16 +6183,11 @@ static int store_super_imsm(struct supertype *st, int fd)
 	if (!mpb)
 		return 1;
 
-#ifndef MDASSEMBLE
 	if (super->sector_size == 4096)
 		convert_to_4k(super);
 	return store_imsm_mpb(fd, mpb);
-#else
-	return 1;
-#endif
 }
 
-#ifndef MDASSEMBLE
 static int validate_geometry_imsm_container(struct supertype *st, int level,
 					    int layout, int raiddisks, int chunk,
 					    unsigned long long size,
@@ -7433,7 +7402,6 @@ static int update_subarray_imsm(struct supertype *st, char *subarray,
 
 	return 0;
 }
-#endif /* MDASSEMBLE */
 
 static int is_gen_migration(struct imsm_dev *dev)
 {
@@ -7467,7 +7435,6 @@ static int is_rebuilding(struct imsm_dev *dev)
 		return 0;
 }
 
-#ifndef MDASSEMBLE
 static int is_initializing(struct imsm_dev *dev)
 {
 	struct imsm_map *migr_map;
@@ -7485,7 +7452,6 @@ static int is_initializing(struct imsm_dev *dev)
 
 	return 0;
 }
-#endif
 
 static void update_recovery_start(struct intel_super *super,
 					struct imsm_dev *dev,
@@ -7519,9 +7485,7 @@ static void update_recovery_start(struct intel_super *super,
 	rebuild->recovery_start = units * blocks_per_migr_unit(super, dev);
 }
 
-#ifndef MDASSEMBLE
 static int recover_backup_imsm(struct supertype *st, struct mdinfo *info);
-#endif
 
 static struct mdinfo *container_content_imsm(struct supertype *st, char *subarray)
 {
@@ -7560,9 +7524,7 @@ static struct mdinfo *container_content_imsm(struct supertype *st, char *subarra
 		struct imsm_map *map2;
 		struct mdinfo *this;
 		int slot;
-#ifndef MDASSEMBLE
 		int chunk;
-#endif
 		char *ep;
 
 		if (subarray &&
@@ -7591,7 +7553,6 @@ static struct mdinfo *container_content_imsm(struct supertype *st, char *subarra
 		super->current_vol = i;
 		getinfo_super_imsm_volume(st, this, NULL);
 		this->next = rest;
-#ifndef MDASSEMBLE
 		chunk = __le16_to_cpu(map->blocks_per_strip) >> 1;
 		/* mdadm does not support all metadata features- set the bit in all arrays state */
 		if (!validate_geometry_imsm_orom(super,
@@ -7606,7 +7567,6 @@ static struct mdinfo *container_content_imsm(struct supertype *st, char *subarra
 			  (1<<MD_SB_BLOCK_CONTAINER_RESHAPE) |
 			  (1<<MD_SB_BLOCK_VOLUME);
 		}
-#endif
 
 		/* if array has bad blocks, set suitable bit in all arrays state */
 		if (sb_errors)
@@ -7697,11 +7657,9 @@ static struct mdinfo *container_content_imsm(struct supertype *st, char *subarra
 		update_recovery_start(super, dev, this);
 		this->array.spare_disks += spare_disks;
 
-#ifndef MDASSEMBLE
 		/* check for reshape */
 		if (this->reshape_active == 1)
 			recover_backup_imsm(st, this);
-#endif
 		rest = this;
 	}
 
@@ -7831,7 +7789,6 @@ static int imsm_count_failed(struct intel_super *super, struct imsm_dev *dev,
 	return failed;
 }
 
-#ifndef MDASSEMBLE
 static int imsm_open_new(struct supertype *c, struct active_array *a,
 			 char *inst)
 {
@@ -10003,7 +9960,6 @@ static void imsm_delete(struct intel_super *super, struct dl **dlp, unsigned ind
 		__free_imsm_disk(dl);
 	}
 }
-#endif /* MDASSEMBLE */
 
 static void close_targets(int *targets, int new_disks)
 {
@@ -10206,7 +10162,7 @@ int validate_container_imsm(struct mdinfo *info)
 
 	return 0;
 }
-#ifndef MDASSEMBLE
+
 /*******************************************************************************
 * Function:   imsm_record_badblock
 * Description: This routine stores new bad block record in BBM log
@@ -11852,10 +11808,7 @@ abort:
 	return ret_val;
 }
 
-#endif /* MDASSEMBLE */
-
 struct superswitch super_imsm = {
-#ifndef	MDASSEMBLE
 	.examine_super	= examine_super_imsm,
 	.brief_examine_super = brief_examine_super_imsm,
 	.brief_examine_subarrays = brief_examine_subarrays_imsm,
@@ -11878,7 +11831,6 @@ struct superswitch super_imsm = {
 	.recover_backup = recover_backup_imsm,
 	.copy_metadata = copy_metadata_imsm,
 	.examine_badblocks = examine_badblocks_imsm,
-#endif
 	.match_home	= match_home_imsm,
 	.uuid_from_super= uuid_from_super_imsm,
 	.getinfo_super  = getinfo_super_imsm,
@@ -11904,7 +11856,6 @@ struct superswitch super_imsm = {
 	.external	= 1,
 	.name = "imsm",
 
-#ifndef MDASSEMBLE
 /* for mdmon */
 	.open_new	= imsm_open_new,
 	.set_array_state= imsm_set_array_state,
@@ -11916,5 +11867,4 @@ struct superswitch super_imsm = {
 	.record_bad_block = imsm_record_badblock,
 	.clear_bad_block  = imsm_clear_badblock,
 	.get_bad_blocks   = imsm_get_badblocks,
-#endif /* MDASSEMBLE */
 };
diff --git a/super-mbr.c b/super-mbr.c
index 1bbe57a..839f000 100644
--- a/super-mbr.c
+++ b/super-mbr.c
@@ -48,8 +48,6 @@ static void free_mbr(struct supertype *st)
 	st->sb = NULL;
 }
 
-#ifndef MDASSEMBLE
-
 static void examine_mbr(struct supertype *st, char *homehost)
 {
 	struct MBR *sb = st->sb;
@@ -71,8 +69,6 @@ static void examine_mbr(struct supertype *st, char *homehost)
 
 }
 
-#endif /*MDASSEMBLE */
-
 static int load_super_mbr(struct supertype *st, int fd, char *devname)
 {
 	/* try to read an mbr
@@ -187,7 +183,6 @@ static struct supertype *match_metadata_desc(char *arg)
 	return st;
 }
 
-#ifndef MDASSEMBLE
 static int validate_geometry(struct supertype *st, int level,
 			     int layout, int raiddisks,
 			     int *chunk, unsigned long long size,
@@ -198,13 +193,10 @@ static int validate_geometry(struct supertype *st, int level,
 	pr_err("mbr metadata cannot be used this way\n");
 	return 0;
 }
-#endif
 
 struct superswitch mbr = {
-#ifndef MDASSEMBLE
 	.examine_super = examine_mbr,
 	.validate_geometry = validate_geometry,
-#endif
 	.match_metadata_desc = match_metadata_desc,
 	.load_super = load_super_mbr,
 	.store_super = store_mbr,
diff --git a/super0.c b/super0.c
index 10d9c40..dc13efb 100644
--- a/super0.c
+++ b/super0.c
@@ -76,8 +76,6 @@ static void super0_swap_endian(struct mdp_superblock_s *sb)
 
 }
 
-#ifndef MDASSEMBLE
-
 static void examine_super0(struct supertype *st, char *homehost)
 {
 	mdp_super_t *sb = st->sb;
@@ -380,7 +378,6 @@ static void brief_detail_super0(struct supertype *st)
 	else
 		printf("%08x", sb->set_uuid0);
 }
-#endif
 
 static int match_home0(struct supertype *st, char *homehost)
 {
@@ -814,7 +811,6 @@ struct devinfo {
 	struct devinfo *next;
 };
 
-#ifndef MDASSEMBLE
 /* Add a device to the superblock being created */
 static int add_to_super0(struct supertype *st, mdu_disk_info_t *dinfo,
 			 int fd, char *devname, unsigned long long data_offset)
@@ -845,7 +841,6 @@ static int add_to_super0(struct supertype *st, mdu_disk_info_t *dinfo,
 
 	return 0;
 }
-#endif
 
 static int store_super0(struct supertype *st, int fd)
 {
@@ -899,7 +894,6 @@ static int store_super0(struct supertype *st, int fd)
 	return 0;
 }
 
-#ifndef MDASSEMBLE
 static int write_init_super0(struct supertype *st)
 {
 	mdp_super_t *sb = st->sb;
@@ -930,7 +924,6 @@ static int write_init_super0(struct supertype *st)
 	}
 	return rv;
 }
-#endif
 
 static int compare_super0(struct supertype *st, struct supertype *tst)
 {
@@ -1261,7 +1254,6 @@ static void free_super0(struct supertype *st)
 	st->sb = NULL;
 }
 
-#ifndef MDASSEMBLE
 static int validate_geometry0(struct supertype *st, int level,
 			      int layout, int raiddisks,
 			      int *chunk, unsigned long long size,
@@ -1320,10 +1312,8 @@ static int validate_geometry0(struct supertype *st, int level,
 	*freesize = MD_NEW_SIZE_SECTORS(ldsize >> 9);
 	return 1;
 }
-#endif /* MDASSEMBLE */
 
 struct superswitch super0 = {
-#ifndef MDASSEMBLE
 	.examine_super = examine_super0,
 	.brief_examine_super = brief_examine_super0,
 	.export_examine_super = export_examine_super0,
@@ -1333,7 +1323,6 @@ struct superswitch super0 = {
 	.validate_geometry = validate_geometry0,
 	.add_to_super = add_to_super0,
 	.copy_metadata = copy_metadata0,
-#endif
 	.match_home = match_home0,
 	.uuid_from_super = uuid_from_super0,
 	.getinfo_super = getinfo_super0,
diff --git a/super1.c b/super1.c
index 6f91611..4db4dff 100644
--- a/super1.c
+++ b/super1.c
@@ -152,7 +152,6 @@ struct misc_dev_info {
 					|MD_FEATURE_PPL			\
 					)
 
-#ifndef MDASSEMBLE
 static int role_from_sb(struct mdp_superblock_1 *sb)
 {
 	unsigned int d;
@@ -165,7 +164,6 @@ static int role_from_sb(struct mdp_superblock_1 *sb)
 		role = MD_DISK_ROLE_SPARE;
 	return role;
 }
-#endif
 
 /* return how many bytes are needed for bitmap, for cluster-md each node
  * should have it's own bitmap */
@@ -304,7 +302,6 @@ static inline unsigned int choose_ppl_space(int chunk)
 	return (PPL_HEADER_SIZE >> 9) + (chunk > 128*2 ? chunk : 128*2);
 }
 
-#ifndef MDASSEMBLE
 static void examine_super1(struct supertype *st, char *homehost)
 {
 	struct mdp_superblock_1 *sb = st->sb;
@@ -903,8 +900,6 @@ static int examine_badblocks_super1(struct supertype *st, int fd, char *devname)
 	return 0;
 }
 
-#endif
-
 static int match_home1(struct supertype *st, char *homehost)
 {
 	struct mdp_superblock_1 *sb = st->sb;
@@ -1276,7 +1271,6 @@ static int update_super1(struct supertype *st, struct mdinfo *info,
 		long bm_sectors = 0;
 		long space;
 
-#ifndef MDASSEMBLE
 		if (sb->feature_map & __cpu_to_le32(MD_FEATURE_BITMAP_OFFSET)) {
 			bitmap_offset = (long)__le32_to_cpu(sb->bitmap_offset);
 			bm_sectors = calc_bitmap_size(bms, 4096) >> 9;
@@ -1284,7 +1278,7 @@ static int update_super1(struct supertype *st, struct mdinfo *info,
 			bitmap_offset = (long)__le16_to_cpu(sb->ppl.offset);
 			bm_sectors = (long)__le16_to_cpu(sb->ppl.size);
 		}
-#endif
+
 		if (sb_offset < data_offset) {
 			/* 1.1 or 1.2.  Put bbl after bitmap leaving at least 32K
 			 */
@@ -1578,7 +1572,7 @@ struct devinfo {
 	mdu_disk_info_t disk;
 	struct devinfo *next;
 };
-#ifndef MDASSEMBLE
+
 /* Add a device to the superblock being created */
 static int add_to_super1(struct supertype *st, mdu_disk_info_t *dk,
 			 int fd, char *devname, unsigned long long data_offset)
@@ -1634,7 +1628,6 @@ static int add_to_super1(struct supertype *st, mdu_disk_info_t *dk,
 
 	return 0;
 }
-#endif
 
 static int locate_bitmap1(struct supertype *st, int fd, int node_num);
 
@@ -1742,8 +1735,6 @@ static unsigned long choose_bm_space(unsigned long devsize)
 
 static void free_super1(struct supertype *st);
 
-#ifndef MDASSEMBLE
-
 __u32 crc32c_le(__u32 crc, unsigned char const *p, size_t len);
 
 static int write_init_ppl1(struct supertype *st, struct mdinfo *info, int fd)
@@ -2028,7 +2019,6 @@ error_out:
 out:
 	return rv;
 }
-#endif
 
 static int compare_super1(struct supertype *st, struct supertype *tst)
 {
@@ -2282,7 +2272,6 @@ static __u64 avail_size1(struct supertype *st, __u64 devsize,
 	if (devsize < 24)
 		return 0;
 
-#ifndef MDASSEMBLE
 	if (__le32_to_cpu(super->feature_map) & MD_FEATURE_BITMAP_OFFSET) {
 		/* hot-add. allow for actual size of bitmap */
 		struct bitmap_super_s *bsb;
@@ -2291,7 +2280,7 @@ static __u64 avail_size1(struct supertype *st, __u64 devsize,
 	} else if (__le32_to_cpu(super->feature_map) & MD_FEATURE_PPL) {
 		bmspace = __le16_to_cpu(super->ppl.size);
 	}
-#endif
+
 	/* Allow space for bad block log */
 	if (super->bblog_size)
 		bbspace = __le16_to_cpu(super->bblog_size);
@@ -2644,7 +2633,6 @@ static void free_super1(struct supertype *st)
 	st->sb = NULL;
 }
 
-#ifndef MDASSEMBLE
 static int validate_geometry1(struct supertype *st, int level,
 			      int layout, int raiddisks,
 			      int *chunk, unsigned long long size,
@@ -2740,7 +2728,6 @@ static int validate_geometry1(struct supertype *st, int level,
 	*freesize = devsize;
 	return 1;
 }
-#endif /* MDASSEMBLE */
 
 void *super1_make_v0(struct supertype *st, struct mdinfo *info, mdp_super_t *sb0)
 {
@@ -2793,7 +2780,6 @@ void *super1_make_v0(struct supertype *st, struct mdinfo *info, mdp_super_t *sb0
 }
 
 struct superswitch super1 = {
-#ifndef MDASSEMBLE
 	.examine_super = examine_super1,
 	.brief_examine_super = brief_examine_super1,
 	.export_examine_super = export_examine_super1,
@@ -2806,7 +2792,6 @@ struct superswitch super1 = {
 	.examine_badblocks = examine_badblocks_super1,
 	.copy_metadata = copy_metadata1,
 	.write_init_ppl = write_init_ppl1,
-#endif
 	.match_home = match_home1,
 	.uuid_from_super = uuid_from_super1,
 	.getinfo_super = getinfo_super1,
diff --git a/util.c b/util.c
index a536f81..a695c45 100644
--- a/util.c
+++ b/util.c
@@ -89,7 +89,6 @@ int dlm_funs_ready(void)
 	return is_dlm_hooks_ready ? 1 : 0;
 }
 
-#ifndef MDASSEMBLE
 static struct dlm_hooks *dlm_hooks = NULL;
 struct dlm_lock_resource *dlm_lock_res = NULL;
 static int ast_called = 0;
@@ -200,16 +199,6 @@ int cluster_release_dlmlock(int lockid)
 out:
 	return ret;
 }
-#else
-int cluster_get_dlmlock(int *lockid)
-{
-	return -1;
-}
-int cluster_release_dlmlock(int lockid)
-{
-	return -1;
-}
-#endif
 
 /*
  * Get array info from the kernel. Longer term we want to deprecate the
@@ -291,7 +280,6 @@ int get_linux_version()
 	return (a*1000000)+(b*1000)+c;
 }
 
-#ifndef MDASSEMBLE
 int mdadm_version(char *version)
 {
 	int a, b, c;
@@ -397,7 +385,6 @@ long parse_num(char *num)
 	else
 		return rv;
 }
-#endif
 
 int parse_cluster_confirm_arg(char *input, char **devname, int *slot)
 {
@@ -639,7 +626,6 @@ char *fname_from_uuid(struct supertype *st, struct mdinfo *info, char *buf, char
 	return __fname_from_uuid(info->uuid, (st->ss == &super1) ? 1 : st->ss->swapuuid, buf, sep);
 }
 
-#ifndef MDASSEMBLE
 int check_ext2(int fd, char *name)
 {
 	/*
@@ -743,7 +729,6 @@ int ask(char *mesg)
 	pr_err("assuming 'no'\n");
 	return 0;
 }
-#endif /* MDASSEMBLE */
 
 int is_standard(char *dev, int *nump)
 {
@@ -803,7 +788,6 @@ unsigned long calc_csum(void *super, int bytes)
 	return csum;
 }
 
-#ifndef MDASSEMBLE
 char *human_size(long long bytes)
 {
 	static char buf[47];
@@ -895,7 +879,6 @@ void print_r10_layout(int layout)
 	if (near*far == 1)
 		printf("NO REDUNDANCY");
 }
-#endif
 
 unsigned long long calc_array_size(int level, int raid_disks, int layout,
 				   int chunksize, unsigned long long devsize)
@@ -962,7 +945,6 @@ dev_t devnm2devid(char *devnm)
 	return 0;
 }
 
-#if !defined(MDASSEMBLE) || defined(MDASSEMBLE) && defined(MDASSEMBLE_AUTO)
 char *get_md_name(char *devnm)
 {
 	/* find /dev/md%d or /dev/md/%d or make a device /dev/.tmp.md%d */
@@ -1016,7 +998,6 @@ void put_md_name(char *name)
 	if (strncmp(name, "/dev/.tmp.md", 12) == 0)
 		unlink(name);
 }
-#endif /* !defined(MDASSEMBLE) || defined(MDASSEMBLE) && defined(MDASSEMBLE_AUTO) */
 
 int get_maj_min(char *dev, int *major, int *minor)
 {
@@ -1146,9 +1127,8 @@ struct superswitch *superlist[] =
 	&super0, &super1,
 	&super_ddf, &super_imsm,
 	&mbr, &gpt,
-	NULL };
-
-#if !defined(MDASSEMBLE) || defined(MDASSEMBLE) && defined(MDASSEMBLE_AUTO)
+	NULL
+};
 
 struct supertype *super_by_fd(int fd, char **subarrayp)
 {
@@ -1213,7 +1193,6 @@ struct supertype *super_by_fd(int fd, char **subarrayp)
 
 	return st;
 }
-#endif /* !defined(MDASSEMBLE) || defined(MDASSEMBLE) && defined(MDASSEMBLE_AUTO) */
 
 int dev_size_from_id(dev_t id, unsigned long long *size)
 {
@@ -1753,7 +1732,7 @@ int add_disk(int mdfd, struct supertype *st,
 {
 	/* Add a device to an array, in one of 2 ways. */
 	int rv;
-#ifndef MDASSEMBLE
+
 	if (st->ss->external) {
 		if (info->disk.state & (1<<MD_DISK_SYNC))
 			info->recovery_start = MaxSector;
@@ -1773,7 +1752,6 @@ int add_disk(int mdfd, struct supertype *st,
 			}
 		}
 	} else
-#endif
 		rv = ioctl(mdfd, ADD_NEW_DISK, &info->disk);
 	return rv;
 }
@@ -1782,12 +1760,11 @@ int remove_disk(int mdfd, struct supertype *st,
 		struct mdinfo *sra, struct mdinfo *info)
 {
 	int rv;
+
 	/* Remove the disk given by 'info' from the array */
-#ifndef MDASSEMBLE
 	if (st->ss->external)
 		rv = sysfs_set_str(sra, info, "slot", "none");
 	else
-#endif
 		rv = ioctl(mdfd, HOT_REMOVE_DISK, makedev(info->disk.major,
 							  info->disk.minor));
 	return rv;
@@ -1832,10 +1809,8 @@ int set_array_info(int mdfd, struct supertype *st, struct mdinfo *info)
 	mdu_array_info_t inf;
 	int rv;
 
-#ifndef MDASSEMBLE
 	if (st->ss->external)
 		return sysfs_set_array(info, 9003);
-#endif
 		
 	memset(&inf, 0, sizeof(inf));
 	inf.major_version = info->array.major_version;
@@ -2015,7 +1990,6 @@ use_random:
 	memcpy(buf, r, 16);
 }
 
-#ifndef MDASSEMBLE
 int flush_metadata_updates(struct supertype *st)
 {
 	int sfd;
@@ -2057,7 +2031,6 @@ void append_metadata_update(struct supertype *st, void *buf, int len)
 	*st->update_tail = mu;
 	st->update_tail = &mu->next;
 }
-#endif /* MDASSEMBLE */
 
 #ifdef __TINYC__
 /* tinyc doesn't optimize this check in ioctl.h out ... */
@@ -2197,7 +2170,6 @@ void reopen_mddev(int mdfd)
 		dup2(fd, mdfd);
 }
 
-#ifndef MDASSEMBLE
 static struct cmap_hooks *cmap_hooks = NULL;
 static int is_cmap_hooks_ready = 0;
 
@@ -2272,4 +2244,3 @@ void set_hooks(void)
 	set_dlm_hooks();
 	set_cmap_hooks();
 }
-#endif
-- 
2.7.4

